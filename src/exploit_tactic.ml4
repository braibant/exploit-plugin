
let pp_constr fmt x = Pp.pp_with fmt (Printer.pr_constr x)

let exploit (c : Term.constr) = fun gl -> 
  (* the type of [c] is [ty] *)
  let ty = Tacmach.pf_type_of gl c in 

  (* ty can be written as [forall (x1:t1) ... (xn:tn), t] 
     here, [ctx] is [(xn, tn); ...; (x1,t1))] *)
  let ctx, t = Term.decompose_prod_assum ty in 

  (* the type of the conclusion of the goal is [concl] *)
  let concl = Tacmach.pf_concl gl in 
  
  (* We want to build the proof term pf
     
     [fun (x1:t1) ... (xn:tn) (m: t -> concl) => m (c x1 .... xn)]
     
     We start to build the body of the proof term [pf_body] *)
  let pf_body = Term.mkApp (Term.mkRel 1, [| Term.mkApp (c, Termops.extended_rel_vect 1 ctx) |]) in

  (* We now need to extend the context to accomodate for the extra
     parameter [m] of type [t -> concl]. 
     
     Note here that the type [t] may depend on the context
     [ctx]. There is no need to lift [t], because it is used in the
     exact same context as before; and there should not be de Bruijn
     indices in [concl].  *)
  
  let ctx = (Names.Anonymous,None, Term.mkArrow t concl ) :: ctx in 
  let pf_term = Term.it_mkLambda_or_LetIn pf_body ctx in

  (* Sanity check: we pretty print the term that we are going to apply*)
  let _ = Format.printf "Proof term produced by the exploit tactic:\n%a\n" pp_constr pf_term in 
  
   (* Unfortunately, Tactics.apply does not generate the sub-goals in
      the exact order we used. So we use a variant of Tactics.refine  *)
   Tactics.apply_term pf_term (List.map (fun _ -> Evarutil.mk_new_meta ()) ctx) gl
    
    
TACTIC EXTEND exploit
  | ["exploit" constr(c)] ->     [exploit c]      END;;


(* Looking carefully at the things we had to do to make the above
   tactics work, we imagine that we should be able to use the following
   tactic instead. 
   
   However, it fails with the following error message.

   Error: Application of lemmas whose beta-iota normal form contains
   metavariables deep inside the term is not supported; try "refine" instead.


let exploit2 c = fun gl -> 
  let ty = Tacmach.pf_type_of gl c in 
  let ctx, t = Term.decompose_prod_assum ty in 
  let concl = Tacmach.pf_concl gl in 
  let mvars = (List.map (fun _ -> Evarutil.mk_new_meta ()) ctx) in 
  let pf_body = Term.mkApp (Term.mkRel 1, [| Term.applist (c, mvars) |]) in 
  let term = Term.mkProd (Names.Anonymous, Term.mkArrow t concl, pf_body) in 
  Tactics.refine (Term.mkApp (term, [|Evarutil.mk_new_meta ()|])) gl
*)
